<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
[
  <!ENTITY % entities SYSTEM "../common/generic-entities.ent">
    %entities;
]>
<!-- refers to legacy doc: <add github link to legacy doc piece, if applicable> -->
<!-- point back to this document with a similar comment added to your legacy doc piece -->
<!-- refer to README.md for file and id naming conventions -->
<!-- metadata is dealt with on the assembly level -->
<topic xml:id="about-kdump"
 role="concept" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.2"
 xmlns:its="http://www.w3.org/2005/11/its"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:trans="http://docbook.org/ns/transclusion">
  <info>
    <title>About &kdump;</title>
    <meta name="maintainer" content="amrita.sakthivel@suse.com" its:translate="no"/>
    <abstract>
      <para>
&kdump; is a kernel crash dumping mechanism that captures the system’s memory state into a vmcore file when
system crash occurs. A vmcore file is a snapshot of your computer's system memory (RAM) taken at the exact moment the Linux kernel crashed.
      </para>
    </abstract>
  </info>
  <section  xml:id="important-kdump">
   <title>Why is &kdump; important?</title>
    <para>The primary importance of &kdump; lies in its ability to capture a snapshot of a system's memory at the exact moment of a critical failure.
      When a Linux kernel experiences a fatal error that halts all operations—standard logging services like syslog or journald usually fail along with it.
 This often leaving no record of what went wrong. &kdump; bypasses this limitation by using &kexec; to boot a secondary capture kernel in a reserved slice of RAM.
 This allows the system to remain stable enough to save the volatile memory (RAM) into a persistent file, known as a vmcore.
 Without this tool, administrators are often left with nothing but a blank screen or a frozen console, making it nearly impossible to diagnose the root cause of intermittent or silent system crashes.</para>
 <para>The vmcore file is a snapshot of the RAM and includes:</para>
 <itemizedlist>
<listitem><para><emphasis role="bold">The Kernel state:</emphasis>All active kernel data structures, global variables and the call stack, which is what the CPU was doing when it died.</para></listitem>
<listitem><para><emphasis role="bold">Process information:</emphasis>A list of every process that was running, including their individual stacks and registers.</para></listitem>
<listitem><para><emphasis role="bold">Memory pages:</emphasis>Depending on your settings, it can contain the actual data held in RAM by applications.</para></listitem>
<listitem><para><emphasis role="bold">VMCOREINFO:</emphasis>special section that tells analysis tools how the kernel's memory was laid out so they can make sense of the raw data.</para></listitem>
 </itemizedlist>
</section>
  <section  xml:id="vmcore-file-kdump">
    <title>About the vmcore file</title>
     <para>
      A vmcore file is a snapshot of your system's physical memory (RAM) taken at the exact moment the Linux kernel crashed.
      When a system panics, the &kdump; service uses 7kexec; to boot a small, separate capture kernel that stays in a reserved slice of RAM.
      This capture kernel’s main function is to look back at the crashed memory and save it to a vmcore file so that you can figure out what happened after the system reboots.
     </para>
   </section>
      <section  xml:id="kexec-kdump">
    <title>What is &kexec;? </title>
     <para></para>
   </section>
</topic>