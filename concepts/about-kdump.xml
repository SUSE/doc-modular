<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
[
  <!ENTITY % entities SYSTEM "../common/generic-entities.ent">
    %entities;
]>
<!-- refers to legacy doc: <add github link to legacy doc piece, if applicable> -->
<!-- point back to this document with a similar comment added to your legacy doc piece -->
<!-- refer to README.md for file and id naming conventions -->
<!-- metadata is dealt with on the assembly level -->
<topic xml:id="about-kdump"
 role="concept" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.2"
 xmlns:its="http://www.w3.org/2005/11/its"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:trans="http://docbook.org/ns/transclusion">
  <info>
    <title>About &kdump;</title>
    <meta name="maintainer" content="amrita.sakthivel@suse.com" its:translate="no"/>
    <abstract>
      <para>
&kdump; is a kernel crash dumping mechanism that captures the system’s memory state into a vmcore file when
system crash occurs. A vmcore file is a snapshot of your computer's system memory (RAM) taken at the exact moment the Linux kernel crashed.
      </para>
    </abstract>
  </info>
  <section  xml:id="important-kdump">
   <title>Why is &kdump; important?</title>
    <para>The primary importance of &kdump; lies in its ability to capture a snapshot of a system's memory at the exact moment of a critical failure.
      When a Linux kernel experiences a fatal error that halts all operations—standard logging services like syslog or journald usually fail along with it.
 This often leaving no record of what went wrong. &kdump; bypasses this limitation by using &kexec; to boot a secondary capture kernel in a reserved slice of RAM.
 This allows the system to remain stable enough to save the volatile memory (RAM) into a persistent file, known as a vmcore.
 Without this tool, administrators are often left with nothing but a blank screen or a frozen console, making it nearly impossible to diagnose the root cause of intermittent or silent system crashes.</para>
 </section>
 <section  xml:id="dual-kernel-kdump">
  <title>Understanding the dual-kernel model</title>
  <para>Dual-kernel model is the usage of a second, isolated kernel to handle a system crash safely. When the main system kernel fails, you can not trust it to write its own crash logs to disk—the memory that might be corrupted
    because the kernel itself is no longer reliable. The dual-kernel approach solves this by jumping into a completely different environment.</para>
 <para>The model relies on two distinct kernels residing in memory simultaneously:</para>
 <itemizedlist>
  <listitem><para><emphasis role="bold">The production (primary) kernel:</emphasis> is the kernel you use every day. It runs your applications and services.</para></listitem>
  <listitem><para><emphasis role="bold">The capture (crash) kernel:</emphasis> is a lightweight, minimal kernel specifically compiled to run in a small, reserved area of RAM. It only wakes up when the primary kernel panics.</para></listitem>
</itemizedlist>
  </section>
  <section  xml:id="vmcore-file-kdump">
    <title>About the vmcore file</title>
     <para>
      A vmcore file is a snapshot of your system's physical memory (RAM) taken at the exact moment the Linux kernel crashed.
      When a system panics, the &kdump; service uses 7kexec; to boot a small, separate capture kernel that stays in a reserved slice of RAM.
      This capture kernel’s main function is to look back at the crashed memory and save it to a vmcore file so that you can figure out what happened after the system reboots.
     </para>
     <para>The vmcore file is a snapshot of the RAM and includes:</para>
 <itemizedlist>
<listitem><para><emphasis role="bold">The Kernel state:</emphasis>All active kernel data structures, global variables and the call stack, which is what the CPU was doing when it died.</para></listitem>
<listitem><para><emphasis role="bold">Process information:</emphasis>A list of every process that was running, including their individual stacks and registers.</para></listitem>
<listitem><para><emphasis role="bold">Memory pages:</emphasis>Depending on your settings, it can contain the actual data held in RAM by applications.</para></listitem>
<listitem><para><emphasis role="bold">VMCOREINFO:</emphasis>special section that tells analysis tools how the kernel's memory was laid out so they can make sense of the raw data.</para></listitem>
 </itemizedlist>
   </section>
      <section  xml:id="kexec-kdump">
    <title>What is &kexec;? </title>
     <para>&kexec; is a system call that functions as a software-defined boot loader, allowing a running kernel to bypass the hardware BIOS/UEFI stage and directly hand over control to a new kernel.
      By loading the secondary kernel's image and parameters into memory while the system is still active, &kexec; performs a warm-up boot that preserves the state of RAM and significantly reduces downtime.
      This mechanism is the backbone of the &kdump; dual-kernel model, as it provides a reliable way to jump from a crashing production environment into a clean recovery environment for data capture.</para>
  <para>The <literal>kexec-tools </literal> package contains a script called <literal>kexec-bootloader</literal>. This script reads the boot loader configuration and runs &kexec; using the same kernel options as the normal boot loader.
  The most important component of &kexec; is the <command>/sbin/kexec</command> command. You can load a kernel with &kexec; in two ways:</para>
<itemizedlist>
<listitem><para>Load the kernel to the address space of a production kernel for a regular reboot:</para>
<screen>&prompt.sudo; kexec -l <replaceable>KERNEL_IMAGE</replaceable> </screen>
<para>You can later boot to this kernel with the command <command>kexec -e</command>.</para>
</listitem>
<listitem><para>Load the kernel to a reserved area of memory:</para>
  <screen>&prompt.sudo; kexec -p <replaceable>KERNEL_IMAGE</replaceable> </screen>
  <para>This kernel is booted automatically when the system crashes.</para>
  </listitem>
</itemizedlist>
</section>
</topic>