<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
[
  <!ENTITY % entities SYSTEM "../common/generic-entities.ent">
    %entities;
]>

<!-- refers to legacy doc: https://github.com/SUSE/doc-sleha/blob/main/xml/ha_resource_constraints.xml -->

<topic xml:id="ha-resources-constraints-what-is"
 role="concept" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.2"
 xmlns:its="http://www.w3.org/2005/11/its"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:trans="http://docbook.org/ns/transclusion">
  <info>
    <title>What are resource constraints?</title>
    <meta name="maintainer" content="tahlia.richardson@suse.com" its:translate="no"/>
    <abstract>
      <para>
        Having all the resources configured is only part of the job. Even if the
    cluster knows all needed resources, it still might not be able to handle
    them correctly. Resource constraints let you specify which cluster nodes
    resources can run on, what order resources load in, and what other
    resources a specific resource is dependent on.
      </para>
    </abstract>
  </info>

<section xml:id="sec-ha-config-basics-constraints-types">
   <title>Types of constraints</title>
   <variablelist>
    <varlistentry>
     <term>Resource location
    </term>
     <listitem>
      <para>
       Location constraints define on which nodes a resource may be
       run, may not be run or is preferred to be run.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Resource colocation</term>
     <listitem>
      <para>
       Colocation constraints tell the cluster which resources may or
       may not run together on a node.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Resource order</term>
     <listitem>
      <para>
       Order constraints define the sequence of actions.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <important>
    <title>Restrictions for constraints and certain types of resources</title>
    <itemizedlist>
     <listitem>
      <para>Do not create colocation constraints for <emphasis>members</emphasis> of a resource
       group. Create a colocation constraint pointing to the resource group as a whole instead. All
       other types of constraints are safe to use for members of a resource group.</para>
     </listitem>
     <listitem>
      <para>Do not use any constraints on a resource that has a clone resource or a promotable clone
       resource applied to it. The constraints must apply to the clone or promotable clone resource, not
       to the child resource.</para>
     </listitem>
    </itemizedlist>
   </important>
  </section>

  <section xml:id="sec-ha-config-basics-constraints-scores">
   <title>Scores and infinity</title>
   <para>
    When defining constraints, you also need to deal with scores. Scores of
    all kinds are integral to how the cluster works. Practically everything
    from migrating a resource to deciding which resource to stop in a
    degraded cluster is achieved by manipulating scores. Scores
    are calculated on a per-resource basis and any node with a negative
    score for a resource cannot run that resource. After calculating the
    scores for a resource, the cluster then chooses the node with the
    highest score.
   </para>
   <para>
    <literal>INFINITY</literal> is currently defined as
    <literal>1,000,000</literal>. Additions or subtractions with it stick to
    the following three basic rules:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Any value + INFINITY = INFINITY
     </para>
    </listitem>
    <listitem>
     <para>
      Any value - INFINITY = -INFINITY
     </para>
    </listitem>
    <listitem>
     <para>
      INFINITY - INFINITY = -INFINITY
     </para>
    </listitem>
   </itemizedlist>
   <para>
    When defining resource constraints, you specify a score for each
    constraint. The score indicates the value you are assigning to this
    resource constraint. Constraints with higher scores are applied before
    those with lower scores. By creating additional location constraints
    with different scores for a given resource, you can specify an order for
    the nodes that a resource fails over to.
   </para>
  </section>

  <section xml:id="sec-ha-config-basics-constraints-templates">
   <title>Resource templates and constraints</title>
   <para>
    If you have defined a resource template, it can be
    referenced in the following types of constraints:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      order constraints
     </para>
    </listitem>
    <listitem>
     <para>
      colocation constraints
     </para>
    </listitem>
   </itemizedlist>
   <para>
    However, colocation constraints must not contain more than one reference
    to a template. Resource sets must not contain a reference to a template.
   </para>
   <para>
    Resource templates referenced in constraints stand for all primitives
    which are derived from that template. This means, the constraint applies
    to all primitive resources referencing the resource template.
    Referencing resource templates in constraints is an alternative to
    resource sets and can simplify the cluster configuration considerably.
   </para>
  </section>

  <section xml:id="sec-ha-config-basics-constraints-rscset">
   <title>Using resource sets to define constraints</title>
   <para>
     As an alternative format for defining location, colocation or order
     constraints, you can use <emphasis>resource sets</emphasis>, where
     primitives are grouped together in one set. Previously this was
     possible either by defining a resource group (which could not always
     accurately express the design), or by defining each relationship as an
     individual constraint. The latter caused a constraint explosion as the
     number of resources and combinations grew. The configuration via
     resource sets is not necessarily less verbose, but is easier to
     understand and maintain.
   </para>
   <para>
     Sets can be either ordered (<literal>sequential=true</literal>) or
     unordered (<literal>sequential=false</literal>). Furthermore, the
     <literal>require-all</literal> attribute can be used to switch between
     <literal>AND</literal> and <literal>OR</literal> logic.
    </para>
   <para>
    Location constraints use curly {} brackets, order and colocation constraints use regular () brackets or sometimes square [] brackets. Why...?
   </para>
  </section>
</topic>
