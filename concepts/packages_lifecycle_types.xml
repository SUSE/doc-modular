<?xml version="1.0" encoding="UTF-8"?>
<!-- This file originates from the project https://github.com/openSUSE/doc-kit -->
<!-- This file can be edited downstream. -->
<!DOCTYPE topic
[
  <!ENTITY % entities SYSTEM "../common/generic-entities.ent">
    %entities;
]>
<!-- refers to legacy doc: <add github link to legacy doc piece, if applicable> -->
<!-- point back to this document with a similar comment added to your legacy doc piece -->
<!-- refer to README.md for file and id naming conventions -->
<!-- metadata is dealt with on the assembly level -->
<topic xml:id="package-lifecycle-categories"
 role="concept" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.2"
 xmlns:its="http://www.w3.org/2005/11/its"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:trans="http://docbook.org/ns/transclusion">
  <info>
    <title>Types of package life cycles</title><!-- can be changed via merge in the assembly -->
    <!--add author's email address-->
    <meta name="maintainer" content="jsindelarova@suse.com" its:translate="no"/>
    <abstract><!-- can be changed via merge in the assembly -->
      <para>
       On &sle; 16, component packages are sorted into different lifecycle categories. This section describes
       the criteria for such a sorting.       
      </para>
    </abstract>
  </info>
  <para>
    When categorizing a package, the impact of its changes on the system is considered. To estimate this impact, the interfaces of the component must first be identified. For example, in the case of a shared library, changes to its API or ABI may disrupt the system. For a compiler or interpreter, disruptive changes may involve supported languages, command-line options, or the performance of the compiled code. By contrast, a minor backward compatible change may have little to no impact.
  </para>
<para>
  In general, a package falls exactly into one of the categories: <emphasis
  role="bold">stable</emphasis>, <emphasis role="bold">balanced</emphasis>, or <emphasis role="bold">agile</emphasis>. However, some technologies may have
  packages sorted into several categories, for example, Python. The following sections
  describe the package categories in detail.  
</para>
  <section xml:id="package-lifecycle-categories-stable">
    <title>Stable</title>
    <para>
      Packages that are marked as stable* (also called conservative) are those that do not deliver a disruptive change
      while a customer is on any of the 16 minor versions. During the upgrade to another minor
      version, the package version may change but the newer version does <emphasis
      role="bold">not</emphasis> introduce incompatible behavior. Customers expect to have LTS on
      these packages.
    </para>
    <para>
      The packages belonging to this category can change, but the following criteria apply:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          changes in functionality are backward compatible: functionality can be added, but not removed
        </para>
      </listitem>
      <listitem>
        <para>
          changes to interfaces are backward compatible
        </para>
      </listitem>
      <listitem>
        <para>
the default behavior of applications does not change unexpectedly
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Under exceptional circumstances like serious security issues, the package can be updated even
      at the cost of bringing disruptive changes. Alternatively, if a new version of a package
      contains disruptive changes, this version can be delivered as an alternative to the previous one.
    </para>
    <para>
      A typical example of a stable package is <literal>util-linux</literal>. Another is
      <literal>glibc</literal>, which remains backward compatible except for symbols deprecated upstream.
    </para>
  </section>
  <section xml:id="package-lifecycle-categories-balanced">
    <title>Balanced</title>
    <para>
      Packages categorized as balanced are changing (driven by upstream evolution and customer demands), but should not cause disruptive changes
      within one minor version. A few incompatible changes are possible, but always
      documented in the release notes for that particular minor release.
    </para>
    <para>
      Customers expect a moderate number of changes during the upgrade from a minor release.
      However, the transition must be smooth, either by getting back to the original behavior or by
      providing the older version in parallel with the new one.  
    </para>
    <para>
      When change is being introduced, it can be in one of the following ways:
    </para>
    <itemizedlist>
      <listitem>
        <para>
A single version is provided with the minor release. The new version replaces the previous one while
allowing for smooth transitions between the versions. New versions are released only with a new
minor release.
        </para>
      </listitem>
      <listitem>
        <para>
          Two versions are provided simultaneously. The new version is introduced in addition to the
          existing version, which then becomes obsolete with the next minor release.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Such versions are supported at least until the end of the LTS of the minor release that introduced them.
    </para>
    <para>
      To help with incorporating changes in a conservative environment, the tick-tock model can be
      used. For example, we could mark even-numbered minor releases as <emphasis>tick</emphasis>
      releases and odd-numbered minor releases as <emphasis>tock</emphasis>. These <emphasis>tock</emphasis> releases could still introduce version updates in packages with a balanced lifecycle, but these updates remain fully backward compatible in all relevant aspects.   
    </para>
    <para>
      For ISVs, a stable runtime environment is critical. Therefore, not to break third-party
      applications, in the case of shared libraries where &suse; provides the corresponding
      <literal>-devel</literal> package, the older <literal>.so</literal> version is not deprecated
      immediately. For example, for a package called <literal>foo</literal>, there are packages:
      <literal>libfoo-0_1</literal>, <literal>foo-devel</literal> and <literal>foo-utils</literal>. 
      If the package is updated and the shared library version changes to 
      <literal>libfoo-0_2</literal>, <literal>libfoo-0_1</literal> is not removed. 
    </para>
    
    <para>
      Typical examples of balanced packages include the following:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          &systemd;: changes should be backward compatible; incompatible changes are
          documented in the release notes
        </para>
      </listitem>
      <listitem>
        <para>
kernel: the kernel is updated with each minor release
        </para>
      </listitem>
      <listitem>
        <para>
          virtualization components: they are updated with each minor release
        </para>
      </listitem>
      <listitem>
        <para>
          MariaDB: a new minor version with each minor release
        </para>
      </listitem>
      <listitem>
        <para>
          PostgreSQL: upstream versions are released on a roughly annual basis, so the
          new version is introduced either with a minor release or as part of a maintenance update for
          an older minor release
        </para>
      </listitem>
      <listitem>
        <para>
          Python: a version supported for a longer period of time with a set of modules on top
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="package-lifecycle-categories-agile">
    <title>Agile</title>
    <para>
      Packages categorized as agile are up to date with upstream even though they may bring
      incompatible changes to the system.
    </para>
    <para>
      Updates to these packages are done in two possible ways:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          With the release of a new package version, one or more older versions are supported for
          customers that cannot switch easily to the new version. There is a sliding window in
          which different versions are supported concurrently (for example, for version N and
          version N - 1). These concurrent versions are supported for a certain period of time that
          can differ from the lifetime of the minor release. 
        </para>
      </listitem>
      <listitem>
        <para>
         The package is just updated without support for the older version. 
        </para>
      </listitem>
    </itemizedlist>
    <para>
      All new package versions are released simultaneously to all minor releases under general support and generally also in LTS.
    </para>
    <para>
      The following packages are categorized as agile:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Go and Rust: a new version is released roughly every 6 months with a sliding
          window of 2 months.
        </para>
      </listitem>
      <listitem>
        <para>
          GCC: a new version of the compiler is released with each minor release with a
          sliding window of 2. However, the libraries <literal>libgcc</literal> and
          <literal>libstdc++</literal> are categorized as stable.
        </para>
      </listitem>
      <listitem>
        <para>
          CLI and SDK for Public Cloud: a new version every quarter, and the new version
          replaces the previous one.
        </para>
      </listitem>
      <listitem>
        <para>
          Python interpreter, library and pip: a new version is released annually.
        </para>
      </listitem>
      <listitem>
        <para>
          Data files for time zones: a new version is released when a new set of definitions becomes available.
        </para>
      </listitem>
    </itemizedlist>
  </section>
</topic>
