<?xml version="1.0" encoding="UTF-8"?>
<!-- This file originates from the project https://github.com/openSUSE/doc-kit -->
<!-- This file can be edited downstream. -->
<!DOCTYPE topic
[
  <!ENTITY % entities SYSTEM "../common/generic-entities.ent">
    %entities;
]>
<!-- refers to legacy doc: <add github link to legacy doc piece, if applicable> -->
<!-- point back to this document with a similar comment added to your legacy doc piece -->
<!-- refer to README.md for file and id naming conventions -->
<!-- metadata is dealt with on the assembly level -->
<topic xml:id="agama-advanced-storage-configuration"
 role="reference" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.2"
 xmlns:its="http://www.w3.org/2005/11/its"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:trans="http://docbook.org/ns/transclusion">
  <info>
    <title>Advanced storage configuration using &agama; profiles</title>
    <!-- can be changed via merge in the assembly -->
    <!--add author's email address-->
    <meta name="maintainer" content="souvik.sarkar@suse.com" its:translate="no"/>
    <abstract>
      <!-- can be changed via merge in the assembly -->
      <para>
        Storage configuration in &agama; is one of the most powerful and flexible components of the
        automated installation process. It allows you to declaratively define everything from
        simple partition layouts to sophisticated combinations&mdash;all before the system is
        booted for the first time.
      </para>

      <para>
        This section illustrates several common use cases with examples. For an exhaustive
        reference of all elements, refer to the schema
        <link xlink:href="https://github.com/agama-project/agama/blob/master/rust/agama-lib/share/storage.schema.json"></link>.
      </para>
    </abstract>
  </info>
  <section xml:id="schema-basics-agama-storage">
    <title>Basic structure of the <literal>storage</literal> schema</title>
    <para>
      A <literal>storage</literal> section contains several entries describing how to configure the
      corresponding storage devices, and some extra entries such as <literal>boot</literal> to
      setup some general aspects that influence the final layout.
    </para>
    <para>
      Each volume group or software RAID can represent a new logical device to be created, or an
      existing device from the system to be processed. Entries below <literal>drives</literal>
      represent devices that can be used as regular disks, which includes removable and fixed
      disks, SD cards, DASD or zFCP devices, iSCSI disks, and multipath devices. Those entries
      always correspond to devices that can be found at the system, because &agama; cannot create
      that kind of devices.
    </para>
    <example>
      <title>Top-level <literal>storage</literal> section syntax</title>
<screen>
"storage": {
  "drives": [ ... ],
  "volumeGroups": [ ... ],
  "mdRaids": [ ... ],
  "boot": { ... }
}
    </screen>
    </example>
    <note>
      <title>Compatibility with legacy Auto&yast; storage</title>
      <para>
        In some cases, <literal>storage</literal> can be replaced by the
        <literal>legacyAutoyastStorage</literal> section. This section supports everything offered
        by the <literal>partitioning</literal> section of the Auto&yast; profile. However, &agama;
        does not validate this special section&mdash;be careful to provide valid Auto&yast;
        options.
      </para>
    </note>
    <para>
      The following sections illustrate certain common use-cases with examples. Before execution,
      it is recommended to validate the configurations using the tools provided by &agama;.
    </para>
  </section>
  <section xml:id="describe-devices-agama-storage">
    <title>Describing the devices</title>
    <para>
      The <literal>drives</literal> collection contains several optional fields, some of which are
      mutually exclusive.
    </para>
    <example>
      <title>Elements in the <literal>drive</literal> collection</title>
<screen>
{
  "alias": "...",
  "search": { ... },
  "encryption": { ... },
  "filesystem": { ... },
  "partitions": [ ... ],
  "ptableType": "..."
}
    </screen>
    </example>
    <para>
      Usually, a device represented by a <literal>drive</literal> entry is divided into several
      partitions. Each entry of <literal>partitions</literal> has the following structure with
      several optional fields:
    </para>
    <example>
      <title>Structure of <literal>partitions</literal></title>
<screen>
{
  "alias": "...",
  "search": { ... },
  "id": "...",
  "size": { ... },
  "encryption": { ... },
  "filesystem": { ... },
  "delete": ...,
  "deleteIfNeeded": ...
}
    </screen>
    </example>
    <para>
      Drives and partitions can be combined such that the one disk is used to create partitions and
      the other is directly formatted.
    </para>
    <example>
      <title>Combination of disks with partitions and direct formatting</title>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        {
          "filesystem": { "path": "/" },
          "size": { "min": "10 GiB" }
        },
        {
          "filesystem": { "path": "swap" },
          "size": "2 GiB"
        }
      ]
    },
    {
      "filesystem": { "path": "/home" },
    }
  ]
}
</screen>
    </example>
    <para>
      An entry from <literal>volumeGroups</literal> can have the following properties:
    </para>
    <example>
      <title>Structure of <literal>volumeGroups</literal></title>
<screen>
{
  "alias": "...",
  "name": "...",
  "search": { ... },
  "physicalVolumes": [ ... ],
  "logicalVolumes": [ ... ],
  "peSize": ... ,
  "delete": ...
}
    </screen>
    </example>
    <para>
      Entries of <literal>logicalVolumes</literal> are relatively similar to the ones used to
      describe partitions.
    </para>
    <example>
      <title>Structure of <literal>logicalVolumes</literal></title>
<screen>
{
  "alias": "...",
  "search": { ... },
  "name": "...",
  "size": { ... },
  "encryption": { ... },
  "filesystem": { ... },
  "pool": ...,
  "usedPool": "...",
  "stripes": ...,
  "stripeSize": ...,
  "delete": ...,
  "deleteIfNeeded": ...
}
    </screen>
    </example>
    <para>
      To understand how all the previously described elements fit together, consider the following
      example in which the first disk of the system is partitioned and a volume group is created on
      top of that partition after encryption, to allocate two file systems.
    </para>
    <example>
      <title>A combination of disk partition, volume groups and file systems</title>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        {
          "alias": "pv",
          "id": "lvm",
          "size": { "min": "12 GiB" },
          "encryption": {
            "luks2": { "password": "my secret passphrase" }
          }
        }
      ]
    }
  ],
  "volumeGroups": [
    {
      "name": "system",
      "physicalVolumes": [ "pv" ],
      "logicalVolumes": [
        {
          "size":   { "min": "10 GiB" },
          "filesystem": { "path": "/", "type": "btrfs" }
        },
        {
          "size":   "2 GiB",
          "filesystem": { "path": "swap", "type": "swap" }
        }
      ]
    }
  ]
}
    </screen>
    </example>
    <para>
      &agama; can also manage software-defined MD RAID arrays represented as entries at the
      <literal>mdRaids</literal> collection.
    </para>
    <example>
      <title>Structure of <literal>mdRaids</literal> collection</title>
<screen>
{
  "alias": "...",
  "name": "...",
  "search": { ... },
  "level": "...",
  "chunkSize": ... ,
  "devices": [ ... ],
  "size": { ... },
  "encryption": { ... },
  "filesystem": { ... },
  "partitions": [ ... ],
  "ptableType": "...",
  "delete": ...
}
</screen>
    </example>
    <para>
      The <literal>devices</literal> property is used to specify the devices that act as members of
      the RAID.
    </para>
    <example>
      <title>An example with <literal>mdRaids</literal> and <literal>devices</literal></title>
<screen>
"storage": {
  "drives": [
    {
      "search": "/dev/sda",
      "partitions": [
        { "alias": "sda-40", "size": "40 GiB" }
      ]
    },
    {
      "search": "/dev/sdb",
      "partitions": [
        { "alias": "sdb-40", "size": "40 GiB" }
      ]
    }
  ],
  "mdRaids": [
    {
      "devices": [ "sda-40", "sdb-40" ],
      "level": "raid0"
    }
  ]
}
</screen>
    </example>
  </section>
  <section xml:id="search-existing-devices-agama-storage">
    <title>Searching existing devices</title>
    <para>
      When a section in the profile describes modification and deletion of devices, the description
      must match with one or more devices from the system. If a description matches several
      devices, the same operations are applied to all of them. This approach is useful in several
      situations, such as applying the same partitioning schema to several disks or deleting all
      partitions of a disk that match a given criteria.
    </para>
    <para>
      Matching is performed using a <literal>search</literal> subsection, as illustrated below. By
      default, all devices in the scope fitting the conditions are matched. You can limit the
      number of devices that match using <literal>max</literal>. The following example shows how
      you can use several search sections to find the three biggest disks in the system, delete all
      partitions bigger than 1 GiB within them and create new partitions of type RAID.
    </para>
    <example>
      <title>Usage of the <literal>search</literal> section</title>
<screen>
"storage": {
  "drives": [
    {
      "search": {
        "sort": { "size": "desc" },
        "max": 3
      },
      "partitions": [
        {
          "search": {
            "condition": { "size": { "greater": "1 GiB" } }
          },
          "delete": true
        },
        {
          "alias": "newRaidPart",
          "id": "raid",
          "size": { "min": "1 GiB" }
        }
      ]
    }
  ]
}
</screen>
    </example>
    <para>
      The scope of each search depends on the place in the profile of the <literal>search</literal>
      section. In the example, the devices from the system that are considered as possible
      candidates. A search section inside the description of an MD RAID only matches the software
      RAID devices. A search section inside the <literal>partitions</literal> subsection of that
      RAID description only matches the partitions of RAIDs that have matched the conditions of the
      most external search.
    </para>
    <para>
      A device can never match two different sections of the &agama; profile. When several sections
      at the same level contain a search subsection, devices are matched in the order the sections
      appear on the profile.
    </para>
    <example>
      <title>Order of device matching</title>
<screen>
"storage": {
  "drives": [
    {
      "search": {
        "sort": { "size": "desc" },
        "max": 1
      },
      "alias": "biggest"
    },
    {
      "search": {
        "sort": { "size": "desc" },
        "max": 1
      },
      "alias": "secondBiggest"
    }
  ]
}
</screen>
    </example>
    <para>
      An empty search matches all devices in the scope. For example, the configuration given below
      deletes all the partitions of the chosen disk, but only if the disk contains partitions.
    </para>
    <example>
      <title>Empty search matching all devices in the scope</title>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        { "search": {}, "delete": true }
      ]
    }
  ]
}
</screen>
    </example>
    <para>
      If there is not a single system device matching the scope and the conditions of a given
      search, then <literal>ifNotFound</literal> is used. If the value is <literal>skip</literal>,
      the device definition is ignored. If the value is <literal>"error"</literal> the whole
      process is aborted.
    </para>
    <para>
      Entries on drives are different from all other subsections describing devices because drives
      can only be matched to existing devices. If search is omitted for a drive, it is considered
      to contain the following configuration:
    </para>
    <example>
      <title>Behavior of <literal>search</literal> if omitted for a drive</title>
<screen>
{
  "search": {
    "sort": "name",
    "max": 1,
    "ifNotFound": "error"
  }
}
</screen>
    </example>
    <para>
      When the syntax of a search subsection becomes cumbersome, you can use simple strings.
    </para>
    <para>
      You can use search to find a device by its name. For example:
    </para>
    <example>
      <title>Searching using device name</title>
<screen>
{ "search": "/dev/sda" }
</screen>
    </example>
    <para>
      The string <literal>*</literal> allows to match all the devices from the current context, if
      any. This is specially useful to match all partitions or logical volumes in a device,
      irrespective of whether there is any. For example, the two following search sections are
      equivalent:
    </para>
    <example>
      <title>Example of equivalent search</title>
<screen>
{ "search": "*" }
</screen>
<screen>
{ "search": { "ifNotFound": "skip" } }
</screen>
    </example>
  </section>
  <section xml:id="reference-other-devices-agama-storage">
    <title>Referencing other devices</title>
    <para>
      At certain times, it is necessary to reference other devices as part of the specification of
      an LVM volume group or RAID. Those devices can be existing system devices, or devices that
      will be created as response to another entry of the &agama; profile. For that purpose, you
      can use <literal>alias</literal>.
    </para>
    <example>
      <title>Using <literal>alias</literal> in storage configuration</title>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        { "size": "50 GiB", "id": "lvm", "alias": "newPV" }
      ]
    }
   ],
   "volumeGroups": [
    {
      "name": "newVG",
      "physicalVolumes": [ "newPV" ],
      "logicalVolumes": [ { "name": "data", "size": "20 GiB" } ]
    }
  ]
}
</screen>
    </example>
    <para>
      If a section matching several existing devices contains an alias, that alias is considered as
      a reference to all the devices. Consider the following equivalent examples that assumes there
      are at least two disks in the system:
    </para>
    <example>
      <title>Equivalent examples of alias</title>
<screen>
"storage": {
  "drives": [
    {
      "search": {
        "sort": { "size": "desc" },
        "max": 1,
      },
      "alias": "biggest"
    },
    {
      "search": {
        "sort": { "size": "desc" },
        "max": 1,
      },
      "alias": "secondBiggest"
    }
  ],
  "mdRaids": [
    {
      "devices": [ "biggest", "secondBiggest" ],
      "level": "raid0"
    }
  ]
}

"storage": {
  "drives": [
    {
      "search": {
        "sort": { "size": "desc" },
        "max": 2,
      },
      "alias": "big"
    }
  ],
  "mdRaids": [
    {
      "devices": [ "big" ],
      "level": "raid0"
    }
  ]
}
</screen>
    </example>
  </section>
  <section xml:id="specify-device-size-agama-storage">
    <title>Specifying the size of a device</title>
    <para>
      When configuring storage in the &agama; profile, you must specify the desired size for a new
      device or the target size when resizing an existing one. The schema allows for flexible size
      specification. The most common method is using a human-readable string that can be parsed
      into a valid size. For example, <literal>10 GiB</literal>. Alternatively, you can provide a
      size as an array (a tuple) containing a minimum size and an optional maximum size. The
      resulting size will be between these two thresholds. If the maximum is omitted, the device
      will expand to consume all available contiguous space, respecting other specified size
      constraints.
    </para>
    <para>
      For configurations targeting existing partitions or Logical Volumes (LVs)&mdash;which must
      include a search section&mdash;the special keyword <literal>current</literal> can be used as
      a minimum or maximum size limit. The use of <literal>current</literal> and how it affects
      resizing the corresponding devices is explained separately.
    </para>
    <para>
      If the size property is completely omitted for an existing device (for example, combined with
      search), &agama; acts as if both minimum and maximum limits were set to
      <literal>current</literal>. This characteristic implies that the partition or logical volume
      are not be resized. If the size is omitted for a device that will be created but includes a
      file system entry specifying a mount point, &agama; can determine the size limits by applying
      the settings of the installation product. In &agama; terminology, the product is the
      operating system being installed, and it specifies the default size ranges for its relevant
      file systems, such as <filename>/</filename>, <filename>swap</filename> and
      <filename>/home</filename>.
    </para>
  </section>
  <section xml:id="partition-boot-agama-storage">
    <title>Partition needed for booting</title>
    <para>
      You can use the <literal>boot</literal> entry to configure whether &agama; should calculate
      and create extra partitions needed for booting. The behavior is same when using an alias. If
      the device is not specified, &agama; takes the location of the root file system as reference.
    </para>
    <example>
      <title>Partitions needed for booting</title>
<screen>
"storage": {
  "drives": [
    {
      "search": "/dev/sda",
      "alias": "bootDisk"
    },
    {
      "search": "/dev/sdb",
      "partitions": [
        { "filesystem": { "path": "/" } }
      ]
    }
  ],
  "boot": {
    "configure": true,
    "device": "bootDisk"
  }
}
</screen>
    </example>
  </section>
  <section xml:id="keep-existing-filesystem-encryption-agama-storage">
    <title>Keeping an existing file system or encryption layer</title>
    <para>
      The entries for both <literal>filesystem</literal> and <literal>encryption</literal> contains
      a <literal>reuse</literal> flag with a default value of <literal>false</literal>. You can use
      it in combination with <literal>search</literal> to specify that the device must not be
      re-formatted or re-encrypted.
    </para>
  </section>
  <section xml:id="delete-shrink-existing-devices-agama-storage">
    <title>Deleting and shrinking existing devices</title>
    <para>
      The storage configuration proposal must allow defining how to manage existing storage
      components, including partitions, LVM logical volumes, MD RAIDs, and LVM volume groups. A
      search mechanism is employed to match a partition or LVM logical volume definition with one
      or more devices already present on the system. Once a match is made, you can specify the
      required action.
    </para>
    <para>
      The component can be marked to be deleted unconditionally, or deleted if needed to free space
      for newly defined devices. It can also be shrunk to a necessary size or shrunk or extended to
      a specific size or range. It is even possible to express combined actions, like attempting to
      shrink a component first and only proceeding to delete it if shrinking doesn't free up enough
      space.
    </para>
    <para>
      Deletion is achieved with the corresponding <literal>delete</literal> flag for unconditional
      deletion or the <literal>deleteIfNeeded</literal> flag for conditional deletion. If either of
      these flags is active for a partition, it is illogical to specify any other usage for it,
      such as declaring a file system. For example, you can configure the proposal to
      unconditionally delete partition number <literal>1</literal> and then conditionally delete
      other partitions as needed to secure the space for a new <literal>30 Gib</literal> partition.
    </para>
    <example>
      <title>Deleting and shrinking existing devices</title>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        {
          "search": {
            "condition": { "number": 1 }
          },
          "delete": true
        },
        { "search": {}, "deleteIfNeeded": true },
        { "size": "30 GiB" }
      ]
    }
  ]
}
</screen>
    </example>
    <para>
      Often some partitions or logical volumes are shrunk only to make space for the declared
      devices. But because resizing is not a destructive operation, you can declare a given
      partition to be resized (shrunk or extended), then formatted and/or mounted.
    </para>
    <note>
      <title>Limitation of resizing</title>
      <para>
        Resizing a partition can be limited depending on its content and the file system type.
      </para>
    </note>
    <para>
      Combining <literal>search</literal> and <literal>resize</literal> is enough to indicate that
      &agama; is expected to resize a given partition, if possible. The keyword
      <literal>current</literal> can be used as <literal>min</literal> and/or
      <literal>max</literal> for the size range, and it is always equivalent to the exact original
      size of the device. The simplest way to use <literal>current</literal> is to just specify
      that the matched device should keep its original size. That is the default for searched (and
      found) devices, if size is completely omitted.
    </para>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        {
          "search": {
            "condition": { "number": 1 }
          },
          "size": { "min": "current", "max": "current" }
        }
      ]
    }
  ]
}
</screen>
    <para>
      You can use other combinations to specify how a device could be resized, if possible. See the
      following examples with explanatory file system labels.
    </para>
    <warning>
      <para>
        The condition <literal>fsLabel</literal> is not yet implemented.
      </para>
    </warning>
    <example>
      <title>Deleting and shrinking of existing devices including the <literal>fsLabel</literal> condition for file system labels</title>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        {
          "search": {
            "condition": { "fsLabel": "shrinkIfNeeded" }
          },
          "size": { "min": 0, "max": "current" }
        },
        {
          "search": {
            "condition": { "fsLabel": "resizeToFixedSize" }
          },
          "size": "15 GiB"
        },
        {
          "search": {
            "condition": { "fsLabel": "resizeByRange" }
          },
          "size": { "min": "10 GiB", "max": "50 GiB" }
        },
        {
          "search": {
            "condition": { "fsLabel": "growAsMuchAsPossible" }
          },
          "size": { "min": "current" }
        },
      ]
    }
  ]
}
</screen>
    </example>
    <para>
      When the size limits are specified as a combination of <literal>current</literal> and a fixed
      value, ensure that the resulting <literal>min</literal> is not bigger than the resulting
      <literal>max</literal>.
    </para>
    <para>
      Both <literal>deleteIfNeeded</literal> and a size range can be combined to indicate that
      &agama; should make space first, by shrinking the partitions and deleting them only if
      shrinking is not enough.
    </para>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        {
          "search": {},
          "size": { "min": 0, "max": "current" },
          "deleteIfNeeded": true
        }
      ]
    }
  ]
}
</screen>
  </section>
  <section xml:id="generate-default-volumes-agama-storage">
    <title>Generating default volumes</title>
    <para>
      Every product provides a configuration which defines the storage volumes. For example,
      feasible file systems for root and default partitions to create. The default or mandatory
      product volumes can be automatically generated by using a <literal>generate</literal> section
      in the <literal>partitions</literal> or <literal>logicalVolumes</literal> sections.
    </para>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        { "generate": "default" }
      ]
    }
  ]
}
</screen>
    <para>
      The <literal>generate</literal> section allows creating the product volumes without
      explicitly writing all of them. The configuration above would be equivalent to the following:
    </para>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        { "filesystem": { "path": "/" } },
        { "filesystem": { "path": "/home" } },
        { "filesystem": { "path": "swap" } }
      ]
    }
  ]
}
</screen>
    <para>
      If any path is explicitly defined, the <literal>generate</literal> section will not generate
      a volume for it. For example, with the following configuration, only root and swap would be
      automatically added.
    </para>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        { "generate": "default" },
        { "filesystem": { "path": "/home" } }
      ]
    }
  ]
}
</screen>
    <para>
      The auto-generated volumes can be also configured. For example, for encrypting the
      partitions:
    </para>
<screen>
"storage": {
  "drives": [
    {
      "partitions": [
        {
          "generate": {
            "partitions": "default",
            "encryption": {
              "luks1": { "password": "12345" }
            }
          }
        }
      ]
    }
  ]
}
</screen>
    <para>
      The <literal>mandatory</literal> keyword can be used for generating only the mandatory
      partitions or logical volumes:
    </para>
<screen>
"storage": {
  "volumeGroups": [
    {
      "name": "system",
      "logicalVolumes": [
        { "generate": "mandatory" }
      ]
    }
  ]
}
</screen>
  </section>
  <section xml:id="generate-physical-volumes-agama-storage">
    <title>Generating physical volumes</title>
    <para>
      You can configure volume groups to explicitly use a set of devices as physical volumes. The
      aliases of the devices to use are added to the list of physical volumes:
    </para>
<screen>
"storage": {
  "drives": [
    {
      "search": "/dev/vda",
      "partitions": [
        { "alias": "pv2", "size": "100 GiB" },
        { "alias": "pv1", "size": "20 GiB" }
      ]
    }
  ],
  "volumeGroups": [
    {
      "name": "system",
      "physicalVolumes": ["pv1", "pv2"]
    }
  ]
}
</screen>
    <para>
      The physical volumes can be automatically generated too, by simply indicating the target
      devices in which to create the partitions. For that, a <literal>generate</literal> section is
      added to the list of physical volumes:
    </para>
<screen>
"storage": {
  "drives": [
    {
      "search": "/dev/vda",
      "alias": "pvs-disk"
    }
  ],
  "volumeGroups": [
    {
      "name": "system",
      "physicalVolumes": [
        { "generate": ["pvs-disk"] }
      ]
    }
  ]
}
</screen>
    <para>
      If the auto-generated physical volumes have to be encrypted, then the encryption config is
      added to the generate section:
    </para>
<screen>
"storage": {
  "drives": [
    {
      "search": "/dev/vda",
      "alias": "pvs-disk"
    }
  ],
  "volumeGroups": [
    {
      "name": "system",
      "physicalVolumes": [
        {
          "generate": {
            "targetDevices": ["pvs-disk"],
            "encryption": {
              "luks2": { "password": "12345" }
            }
          }
        }
      ]
    }
  ]
}
</screen>
  </section>
</topic>
