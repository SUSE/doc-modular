<?xml version="1.0" encoding="UTF-8"?>
<!-- This file originates from the project https://github.com/openSUSE/doc-kit -->
<!-- This file can be edited downstream. -->
<!DOCTYPE topic
[
  <!ENTITY % entities SYSTEM "../common/generic-entities.ent">
    %entities;
]>
<topic xml:id="ansible-basic-usage"
 role="reference" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.2"
 xmlns:its="http://www.w3.org/2005/11/its"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:trans="http://docbook.org/ns/transclusion">
  <info>
    <title>Basic usage of Ansible</title>
    <meta name="maintainer" content="amrita.sakthivel@suse.com" its:translate="no"/>
    <abstract>
      <para>
        Ansible provides ad-hoc commands and several utilities to perform various operation and automation
        tasks. Ad-hoc commands in Ansible are useful for performing quick and one-off tasks that do not need to be saved for future use.
        They are single line commands executed directly from the command line. Ad-hoc commands use the <literal>ansible</literal> CLI tool.
      </para>
      <para> In contrast, playbooks are a more powerful and scalable solution for defining complex, multi-step IT automation tasks.
        They are written in YAML and contain a list of plays, with each play associating a group of hosts with a series of tasks.
        The <literal>ansible-playbook</literal> CLI tool is used to execute these playbooks. This approach promotes reusability, version control
        and collaboration, making it the preferred method for managing and deploying applications at scale. </para>
      <para>You can use either ad-hoc commands or create a playbook to automate your IT infrastructure based on your use case. </para>
        </abstract>
  </info>

     <section xml:id="ansible-ad-hoc">
      <title>Ad-hoc commands</title>
              <para>Ad-hoc commands are a quick way to run a single task on one or more managed hosts directly from the command.
                Ideal for simple operations like checking system uptime or rebooting a server.</para>
        <para>They are useful for quickly managing servers by performing actions like rebooting, copying files and managing packages and users.
          You can use any of the available Ansible modules in an ad-hoc task. Like playbooks, ad-hoc tasks use a <emphasis>declarative</emphasis>
           model, where you define the desired final state. Ansible then automatically calculates and executes the necessary steps to achieve that state.
           This approach ensures the task can be run multiple times without causing unintended changes, as Ansible first checks the
          current state of the host and only performs an action if it differs from the specified final state.</para>
      </section>
      <section xml:id="ansible-cli-tools">
        <title>Ansible command-line tools</title>
        <para>
        Ansible provides the following command-line tools:</para>
        <variablelist>
          <varlistentry>
            <term><literal>ansible</literal></term>
            <listitem>
              <para>
            A simple tool or framework for remote tasks; this command-line tool allows you to define and run a single task
           playbook against a set of hosts.</para>
           <screen>&prompt.user;<command>ansible -h</command>
            usage: ansible [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER] [-K | --become-password-file BECOME_PASSWORD_FILE] [-i INVENTORY] [--list-hosts]
                           [-l SUBSET] [-P POLL_INTERVAL] [-B SECONDS] [-o] [-t TREE] [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT]
                           [--ssh-common-args SSH_COMMON_ARGS] [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS] [--ssh-extra-args SSH_EXTRA_ARGS] [-k |
                           --connection-password-file CONNECTION_PASSWORD_FILE] [-C] [-D] [-e EXTRA_VARS] [--vault-id VAULT_IDS] [-J | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS]
                           [-M MODULE_PATH] [--playbook-dir BASEDIR] [--task-timeout TASK_TIMEOUT] [-a MODULE_ARGS] [-m MODULE_NAME]
                          pattern
                          Define and run a single task 'playbook' against a set of hosts
                          [...]
                        </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-config</literal></term>
            <listitem>
              <para>
            Used to manage and view Ansible's configuration settings. </para>
           <screen>&prompt.user;<command>ansible-config -h</command>
            usage: ansible-config [-h] [--version] [-v] {list,dump,view,init,validate} ...

View ansible configuration.

positional arguments:
  {list,dump,view,init,validate}
    list                Print all config options
    dump                Dump configuration
    view                View configuration file
    init                Create initial configuration
    validate            Validate the configuration file and environment variables. By default it only checks the base settings without accounting for plugins (see -t).

options:
  --version             show program's version number, config file location, configured module search path, module location, executable location and exit
  -h, --help            show this help message and exit
  -v, --verbose         Causes Ansible to print more debug messages. Adding multiple -v will increase the verbosity, the builtin plugins currently evaluate up to -vvvvvv. A
                        reasonable level to start is -vvv, connection debugging might require -vvvv. This argument may be specified multiple times.</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-console</literal></term>
            <listitem>
              <para>
            An interactive command-line tool or Read-Eval-Print Loop (REPL), that lets you run Ansible ad-hoc commands in a persistent real-time shell environment.
            It is a great tool for quickly testing modules, exploring your inventory and debugging issues without having to run a new command for every action.
              </para>
           <screen>&prompt.user;<command>ansible-console -h</command>
            usage: ansible-console [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER] [-K | --become-password-file BECOME_PASSWORD_FILE] [-i INVENTORY]
            [--list-hosts] [-l SUBSET] [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT] [--ssh-common-args SSH_COMMON_ARGS]
            [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS] [--ssh-extra-args SSH_EXTRA_ARGS] [-k |
            --connection-password-file CONNECTION_PASSWORD_FILE] [-C] [-D] [--vault-id VAULT_IDS] [-J | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS]
            [-M MODULE_PATH] [--playbook-dir BASEDIR] [-e EXTRA_VARS] [--task-timeout TASK_TIMEOUT] [--step]
            [pattern]

REPL console for executing Ansible tasks.
                          [...]
                        </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-doc</literal></term>
            <listitem>
              <para>
          A command-line tool that provides documentation for all Ansible's installed modules and plugins.
          It is an essential utility for anyone writing playbooks or ad-hoc commands. You can look up a module's purpose, parameters, return , and even usage examples directly from your terminal.
            </para>
           <screen>&prompt.user;<command>ansible-doc -h</command>
            usage: ansible-doc [-h] [--version] [-v] [-M MODULE_PATH] [--playbook-dir BASEDIR]
                   [-t {become,cache,callback,cliconf,connection,httpapi,inventory,lookup,netconf,shell,vars,module,strategy,test,filter,role,keyword}] [-j] [-r ROLES_PATH]
                   [-e ENTRY_POINT | -s | -F | -l | --metadata-dump] [--no-fail-on-errors]
                   [plugin ...]

plugin documentation tool
                          [...]
                        </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-galaxy</literal></term>
            <listitem>
              <para>
          A command-line tool that comes with Ansible and is used for managing and sharing roles. </para>
           <screen>&prompt.user;<command>ansible-galaxy -h</command>
            Perform various Role and Collection related operations.

positional arguments:
  TYPE
    collection   Manage an Ansible Galaxy collection.
    role         Manage an Ansible Galaxy role.

options:
  --version      show program's version number, config file location, configured module search path, module location, executable location and exit
  -h, --help     show this help message and exit
  -v, --verbose  Causes Ansible to print more debug messages. Adding multiple -v will increase the verbosity, the builtin plugins currently evaluate up to -vvvvvv. A reasonable level
                 to start is -vvv, connection debugging might require -vvvv. This argument may be specified multiple times.
                        </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-inventory</literal></term>
            <listitem>
              <para>
Is a command-line tool that helps you inspect, validate and understand your inventory.</para>
           <screen>&prompt.user;<command>ansible-inventory -h</command>
            usage: ansible-inventory [-h] [--version] [-v] [-i INVENTORY] [-l SUBSET] [--vault-id VAULT_IDS] [-J | --vault-password-file VAULT_PASSWORD_FILES] [--playbook-dir BASEDIR]
                         [-e EXTRA_VARS] [--list] [--host HOST] [--graph] [-y] [--toml] [--vars] [--export] [--output OUTPUT_FILE]
                         [group]

Show Ansible inventory information, by default it uses the inventory script JSON format
[...]
  </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-playbook</literal></term>
            <listitem>
              <para>
Is a primary command-line tool used to run Ansible's automation blueprints also known as playbooks, against an inventory of target hosts.</para>
           <screen>&prompt.user;<command>ansible-playbook -h</command>
            usage: ansible-playbook [-h] [--version] [-v] [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT] [--ssh-common-args SSH_COMMON_ARGS]
                        [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS] [--ssh-extra-args SSH_EXTRA_ARGS] [-k |
                        --connection-password-file CONNECTION_PASSWORD_FILE] [--force-handlers] [--flush-cache] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER] [-K |
                        --become-password-file BECOME_PASSWORD_FILE] [-t TAGS] [--skip-tags SKIP_TAGS] [-C] [-D] [-i INVENTORY] [--list-hosts] [-l SUBSET] [-e EXTRA_VARS]
                        [--vault-id VAULT_IDS] [-J | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS] [-M MODULE_PATH] [--syntax-check] [--list-tasks] [--list-tags] [--step]
                        [--start-at-task START_AT_TASK]
                        playbook [playbook ...]

Runs Ansible playbooks, executing the defined tasks on the targeted hosts.
[...]
  </screen>
            </listitem>
          </varlistentry>
            <varlistentry>
            <term><literal>ansible-vault</literal></term>
            <listitem>
              <para>Is a command-line tool that allows you to encrypt sensitive data, such as passwords, API keys and other secrets
                and store them securely within your playbooks and other configuration files.</para>
           <screen>&prompt.user;<command>ansible-vault -h</command>
            usage: ansible-vault [-h] [--version] [-v] {create,decrypt,edit,view,encrypt,encrypt_string,rekey} ...

encryption/decryption utility for Ansible data files

[...]
  </screen>
            </listitem>
          </varlistentry>
                 </variablelist>
       </section>
       <section xml:id="ansible-ssh-config">
        <title>Configuring SSH</title>
        <para>By default, Ansible assumes SSH keys are being used between a control and managed nodes to establish connection.
         To set up SSH key-based authentication from the control node to the managed nodes:</para>
         <procedure>
      <step><para>Generate a key pair on the control node.</para>
      <para>It is recommended to use a dedicated SSH key that is clearly defined in the variable <literal>ansible_ssh_private_key_file</literal>.</para>
       </step>
      <step><para>Copy the public key to the managed node.</para>
<screen>&prompt.user;<command>ssh-copy-id -i <replaceable>PATH_TO_PUBLIC_KEY</replaceable> <replaceable>TARGET_USER</replaceable>@<replaceable>IP_ADDRESS/HOSTNAME</replaceable></command></screen>
      <para>This one-time setup allows Ansible to connect securely without prompting for credentials during automation.</para>
      </step>
         <step><para>Add the private key to the control node.</para>
<screen>&prompt.user;<command>ssh-add <replaceable>PATH_TO_PRIVATE_KEY</replaceable></command>
                  </screen>
           </step>
        </procedure>
        </section>
             <section xml:id="ansible-playbook">
       <title>Creating a playbook </title>
        <para>
         An Ansible playbook is a <literal>YAML</literal> file that defines a series of tasks to be executed on one or more hosts.
         This topic covers creating a simple playbook.
          </para>
       <procedure>
        <step><para>Define an inventory file, for example:</para>
    <screen>
      [all]
      192.168.122.154 ansible_user=user1
    </screen>
    <para>Although Ansible uses <filename>etc/ansible/hosts</filename> by default, it is a      best practice to maintain a separate inventory file and specify it using the<literal>--inventory</literal> flag.</para>
      </step>
      <step><para>Verify your inventory file, for example:</para>
<screen>&prompt.user;<command>ansible-inventory --inventory test.ini --list</command>
        </screen>
      </step>
      <step><para>Test the connection between the control node and managed nodes with the Ansible ad-hoc command:</para>
<screen>&prompt.user;<command>ansible all -i test.ini -m ping</command></screen>
      <para>If the configuration is correct, the following message is displayed:</para>
      <screen>
        [WARNING]: Platform linux on host 192.168.122.73 is using the discovered Python interpreter at /usr/bin/python3.13, but future installation of another Python interpreter could change
        the meaning of that path. See https://docs.ansible.com/ansible-core/2.18/reference_appendices/interpreter_discovery.html for more information.
        192.168.122.73 | SUCCESS => {
            "ansible_facts": {
                "discovered_interpreter_python": "/usr/bin/python3.13"
            },</screen>
      <para>This confirms Ansible can reach the managed nodes securely via SSH. </para>
      </step>
      <step><para>Playbooks are <literal>YAML</literal> files that define the tasks Ansible should perform.
      For example, create a file named <literal>install.yml</literal> to define a task to install common packages on all managed &suse; systems:</para>
<screen>
    - name: Ensure essential packages are present
      hosts: all
      become: true
      tasks:
        - name: Install vim and curl
          ansible.builtin.package:
            name:
              - suseconnect
              - curl
            state: present
    </screen>
    </step>
    <step><para>Run the playbook in check mode:</para>
    <screen>&prompt.user; <command>ansible-playbook install.yml --check</command></screen>
    <para>Check mode is a simulation, it does not generate output for tasks. It validates a configuration management playbook that runs on one node at a time and is useful for
    simple playbooks.</para>
    </step>
    <step><para>Run the playbook:</para>
<screen>&prompt.user; <command>ansible-playbook -i hosts.ini install.yml</command> </screen>
    <para>Ansible connects to each host in your inventory and executes the defined tasks using the system's package manager.</para>
    </step>
    </procedure>
        </section>
   <section xml:id="ansible-roles">
    <title>Understanding roles</title>
<para>Roles allow you to easily reuse and share your Ansible automation by using a known file structure to automatically load all related artifacts, including tasks, variables, files, and handlers.</para>
<section xml:id="use-role">
  <title>Using roles</title>
  <para>You can use the role in the following ways:</para>
  <itemizedlist>
    <listitem><para>At the play level with the <literal>roles</literal>: This is the default way of using roles in a play.</para> </listitem>
    <listitem><para>At the tasks level with <literal>include_role</literal>: You can reuse roles dynamically anywhere in the <literal>tasks</literal> section of a play using <literal>include_role</literal>.</para> </listitem>
    <listitem><para>At the tasks level with <literal>import_role</literal>: You can reuse roles dynamically anywhere in the <literal>tasks</literal> section of a play using <literal>import_role</literal>.</para> </listitem>
    <listitem><para>As a dependency of another role.</para> </listitem>
  </itemizedlist>
  </section>
  <section xml:id="import-role">
  <title>Importing roles</title>
  <para>You can reuse roles statically anywhere in the <literal>tasks</literal> section of a play by using <literal>import_role</literal>. For example:</para>
<screen>
  ---
  - hosts: webservers
    tasks:
      - name: Print a message
        ansible.builtin.debug:
          msg: "before we run our role"

      - name: Apply standard user and group setup from 'base_users' role
        ansible.builtin.import_role:
          name: base_users

      - name: Print a message
        ansible.builtin.debug:
          msg: "after we ran our role"
  </screen>
  <para>You can use other keywords, for example:</para>
<screen>
  ---
  - hosts: webservers
    tasks:
      - name: Import the foo_app_instance role
        ansible.builtin.import_role:
          name: test_app_instance
        vars:
          dir: '/opt/a'
          app_port: 5000
</screen>
</section>
</section>
<section xml:id="about-variables">
<title>About variables</title>
<para>With Ansible, you can run tasks and playbooks with a single command. You can define these variables using standard YAML syntax (including lists and dictionaries) in your playbooks, inventories, roles, or at the command line.
  You can also create new variables dynamically during a playbook run.</para>
  <section xml:id="var-place">
<title>Variable placement</title>
<para>When you define the same variable in multiple locations, Ansible uses variable precedence to determine which value to apply.
   This fixed order governs how different variable sources override one another during execution.
  Variable precedence is defined in the following order with the least to greatest (the last listed variable override all other variables):
  </para>
<itemizedlist>
<listitem><para>Command-line values </para></listitem>
<listitem><para>Role defaults </para></listitem>
<listitem><para>Inventory file or script group vars  </para></listitem>
<listitem><para>Inventory <literal>group_vars/all</literal> </para></listitem>
<listitem><para>Playbook <literal>group_vars/all</literal> </para></listitem>
<listitem><para>Inventory <literal>group_vars/*</literal> </para></listitem>
<listitem><para>Playbook <literal>group_vars/* </literal> </para></listitem>
<listitem><para>Inventory file or script host vars</para></listitem>
<listitem><para>Inventory <literal>host_vars/*</literal> </para></listitem>
<listitem><para>Playbook <literal>host_vars/*</literal> </para></listitem>
<listitem><para>Host facts and cached <literal>set_facts</literal> </para></listitem>
<listitem><para>Play <literal>vars</literal> </para></listitem>
<listitem><para>Play <literal>vars_prompt</literal> </para></listitem>
<listitem><para>Play <literal>vars_files</literal> </para></listitem>
<listitem><para>Role vars </para></listitem>
<listitem><para>Block vars</para></listitem>
<listitem><para>Task vars</para></listitem>
<listitem><para><literal>include_vars</literal> </para></listitem>
<listitem><para>Registered vars and  <literal>set_facts</literal> </para></listitem>
<listitem><para>Role and <literal>include_role</literal> params. </para></listitem>
<listitem><para>include params </para></listitem>
<listitem><para>extra vars </para></listitem>
</itemizedlist>
<para>Ansible gives precedence to variables defined more recently,more active and with more explicit scope. Variables inside a <literal>default
</literal>folder are easily overridden. Anything in the <literal>vars</literal> directory of the role overrides previous versions
of that variable in the namespace.</para>
  </section>
<section xml:id="set-variables">
  <title>Setting variables </title>
  <para>
You can define variables in an inventory, in playbooks, in reusable files, in roles and at the command line.
Ansible loads all the variables it finds and then chooses which variable to apply based on variable precedence.
  </para>
<itemizedlist>
<listitem><para><emphasis role="bold"> Defining variables in an inventory</emphasis>: You can either define different variables for each host or set shared variables for a group of hosts in your inventory.
For example, if all systems in the <literal>manhattan</literal> group use <literal>manhattan.ntp.example.com</literal> as an NTP server, you can use a group variable.
</para></listitem>
<listitem><para><emphasis role="bold"> Defining variables in a play</emphasis>: You can define variables directly in a play. When you define variables directly, they are visible only to the tasks executed in that play.
  </para></listitem>
   <listitem><para><emphasis role="bold"> Defining variables in includes files and roles</emphasis>:
    You can define variables in reusable variables files or reusable roles. If you define variables in reusable variable files or roles, the sensitive variables are separated from playbooks.
    This separation enables you to store your playbooks in a source control software and even share the playbooks, without the risk of exposing passwords or other sensitive and personal data.
    For example:</para>
<screen>
  ---

  - hosts: all
    remote_user: root
    vars:
      favcolor: blue
    vars_files:
      - /vars/test.yml

    tasks:

    - name: This is just a placeholder
      ansible.builtin.command: /bin/echo foo
  </screen>
<para>The content each variables file is a simple YAML dictionary. For example, <filename>/vars/test.yml</filename> :</para>
<screen>
  ---
  somevar: value1
  password: test1
</screen>
  </listitem>
  </itemizedlist>
  </section>
</section>
    </topic>
