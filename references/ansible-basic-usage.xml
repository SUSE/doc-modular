<?xml version="1.0" encoding="UTF-8"?>
<!-- This file originates from the project https://github.com/openSUSE/doc-kit -->
<!-- This file can be edited downstream. -->
<!DOCTYPE topic
[
  <!ENTITY % entities SYSTEM "../common/generic-entities.ent">
    %entities;
]>
<topic xml:id="ansible-basic-usage"
 role="reference" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.2"
 xmlns:its="http://www.w3.org/2005/11/its"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:trans="http://docbook.org/ns/transclusion">
  <info>
    <title>Basic usage of Ansible</title>
    <meta name="maintainer" content="amrita.sakthivel@suse.com" its:translate="no"/>
    <abstract>
      <para>
        Ansible provides ad-hoc commands and several utilities to perform various operation and automation
        tasks. Ad-hoc commands in Ansible are useful for performing quick and one-off tasks that do not need to be saved for future use.
        They are single line commands executed directly from the command line. Ad-hoc commands use the <literal>ansible</literal> CLI tool.
      </para>
      <para> In contrast, playbooks are a more powerful and scalable solution for defining complex, multi-step IT automation tasks.
        They are written in YAML and contain a list of plays, with each play associating a group of hosts with a series of tasks.
        The <literal>ansible-playbook</literal> CLI tool is used to execute these playbooks. This approach promotes reusability, version control,
        and collaboration, making it the preferred method for managing and deploying applications at scale. </para>
      <para>You can use either ad-hoc commands or create a playbook to automate your IT infrastructure based on your use case. </para>
        </abstract>
  </info>

     <section xml:id="ansible-ad-hoc">
      <title>Ad-hoc commands</title>
              <para>Ad-hoc commands are a quick way to run a single task on one or more managed hosts directly from the command.
                Ideal for simple operations like checking system uptime or rebooting a server.</para>
        <para>They are useful for quickly managing servers by performing actions like rebooting, copying files and managing packages and users.
          You can use any of the available Ansible modules in an ad-hoc task. Like playbooks, ad-hoc tasks use a <emphasis>declarative</emphasis>
           model, where you define the desired final state. Ansible then automatically calculates and executes the necessary steps to achieve that state.
           This approach ensures the task can be run multiple times without causing unintended changes, as Ansible first checks the
          current state of the host and only performs an action if it differs from the specified final state.</para>
      </section>
      <section xml:id="ansible-cli-tools">
        <title>Ansible command-line tools</title>
        <para>
        Ansible provides the following command-line tools:</para>
        <variablelist>
          <varlistentry>
            <term><literal>ansible</literal></term>
            <listitem>
              <para>
            A simple tool or framework for remote tasks; this command-line tool allows you to define and run a single task
           playbook against a set of hosts.</para>
           <screen>&prompt.user;ansible -h
            usage: ansible [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER] [-K | --become-password-file BECOME_PASSWORD_FILE] [-i INVENTORY] [--list-hosts]
                           [-l SUBSET] [-P POLL_INTERVAL] [-B SECONDS] [-o] [-t TREE] [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT]
                           [--ssh-common-args SSH_COMMON_ARGS] [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS] [--ssh-extra-args SSH_EXTRA_ARGS] [-k |
                           --connection-password-file CONNECTION_PASSWORD_FILE] [-C] [-D] [-e EXTRA_VARS] [--vault-id VAULT_IDS] [-J | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS]
                           [-M MODULE_PATH] [--playbook-dir BASEDIR] [--task-timeout TASK_TIMEOUT] [-a MODULE_ARGS] [-m MODULE_NAME]
                          pattern
                          Define and run a single task 'playbook' against a set of hosts
                          [...]
                        </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-config</literal></term>
            <listitem>
              <para>
            Used to manage and view Ansible's configuration settings. </para>
           <screen>&prompt.user;ansible-config -h
            usage: ansible-config [-h] [--version] [-v] {list,dump,view,init,validate} ...

View ansible configuration.

positional arguments:
  {list,dump,view,init,validate}
    list                Print all config options
    dump                Dump configuration
    view                View configuration file
    init                Create initial configuration
    validate            Validate the configuration file and environment variables. By default it only checks the base settings without accounting for plugins (see -t).

options:
  --version             show program's version number, config file location, configured module search path, module location, executable location and exit
  -h, --help            show this help message and exit
  -v, --verbose         Causes Ansible to print more debug messages. Adding multiple -v will increase the verbosity, the builtin plugins currently evaluate up to -vvvvvv. A
                        reasonable level to start is -vvv, connection debugging might require -vvvv. This argument may be specified multiple times.</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-console</literal></term>
            <listitem>
              <para>
            An interactive command-line tool or Read-Eval-Print Loop (REPL), that lets you run Ansible ad-hoc commands in a persistent real-time shell environment.
            It is a great tool for quickly testing modules, exploring your inventory and debugging issues without having to run a new command for every action.
              </para>
           <screen>&prompt.user;ansible-console -h
            usage: ansible-console [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER] [-K | --become-password-file BECOME_PASSWORD_FILE] [-i INVENTORY]
            [--list-hosts] [-l SUBSET] [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT] [--ssh-common-args SSH_COMMON_ARGS]
            [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS] [--ssh-extra-args SSH_EXTRA_ARGS] [-k |
            --connection-password-file CONNECTION_PASSWORD_FILE] [-C] [-D] [--vault-id VAULT_IDS] [-J | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS]
            [-M MODULE_PATH] [--playbook-dir BASEDIR] [-e EXTRA_VARS] [--task-timeout TASK_TIMEOUT] [--step]
            [pattern]

REPL console for executing Ansible tasks.
                          [...]
                        </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-doc</literal></term>
            <listitem>
              <para>
          A command-line tool that provides documentation for all Ansible's installed modules and plugins.
          It is an essential utility for anyone writing playbooks or ad-hoc commands. You can look up a module's purpose, parameters, return , and even usage examples directly from your terminal.
            </para>
           <screen>&prompt.user;ansible-doc -h
            usage: ansible-doc [-h] [--version] [-v] [-M MODULE_PATH] [--playbook-dir BASEDIR]
                   [-t {become,cache,callback,cliconf,connection,httpapi,inventory,lookup,netconf,shell,vars,module,strategy,test,filter,role,keyword}] [-j] [-r ROLES_PATH]
                   [-e ENTRY_POINT | -s | -F | -l | --metadata-dump] [--no-fail-on-errors]
                   [plugin ...]

plugin documentation tool
                          [...]
                        </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-galaxy</literal></term>
            <listitem>
              <para>
          A command-line tool that comes with Ansible and is used for managing and sharing roles. </para>
           <screen>&prompt.user;ansible-galaxy -h
            Perform various Role and Collection related operations.

positional arguments:
  TYPE
    collection   Manage an Ansible Galaxy collection.
    role         Manage an Ansible Galaxy role.

options:
  --version      show program's version number, config file location, configured module search path, module location, executable location and exit
  -h, --help     show this help message and exit
  -v, --verbose  Causes Ansible to print more debug messages. Adding multiple -v will increase the verbosity, the builtin plugins currently evaluate up to -vvvvvv. A reasonable level
                 to start is -vvv, connection debugging might require -vvvv. This argument may be specified multiple times.
                        </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-inventory</literal></term>
            <listitem>
              <para>
Is a command-line tool that helps you inspect, validate and understand your inventory.</para>
           <screen>&prompt.user;ansible-inventory -h
            usage: ansible-inventory [-h] [--version] [-v] [-i INVENTORY] [-l SUBSET] [--vault-id VAULT_IDS] [-J | --vault-password-file VAULT_PASSWORD_FILES] [--playbook-dir BASEDIR]
                         [-e EXTRA_VARS] [--list] [--host HOST] [--graph] [-y] [--toml] [--vars] [--export] [--output OUTPUT_FILE]
                         [group]

Show Ansible inventory information, by default it uses the inventory script JSON format
[...]
  </screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ansible-playbook</literal></term>
            <listitem>
              <para>
Is a command-line tool that helps you inspect, validate and understand your inventory.</para>
           <screen>&prompt.user;ansible-playbook -h
            usage: ansible-playbook [-h] [--version] [-v] [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT] [--ssh-common-args SSH_COMMON_ARGS]
                        [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS] [--ssh-extra-args SSH_EXTRA_ARGS] [-k |
                        --connection-password-file CONNECTION_PASSWORD_FILE] [--force-handlers] [--flush-cache] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER] [-K |
                        --become-password-file BECOME_PASSWORD_FILE] [-t TAGS] [--skip-tags SKIP_TAGS] [-C] [-D] [-i INVENTORY] [--list-hosts] [-l SUBSET] [-e EXTRA_VARS]
                        [--vault-id VAULT_IDS] [-J | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS] [-M MODULE_PATH] [--syntax-check] [--list-tasks] [--list-tags] [--step]
                        [--start-at-task START_AT_TASK]
                        playbook [playbook ...]

Runs Ansible playbooks, executing the defined tasks on the targeted hosts.
[...]
  </screen>
            </listitem>
          </varlistentry>
            <varlistentry>
            <term><literal>ansible-vault</literal></term>
            <listitem>
              <para>Is a command-line tool that allows you to encrypt sensitive data, such as passwords, API keys and other secrets
                and store them securely within your playbooks and other configuration files.</para>
           <screen>&prompt.user;ansible-vault -h
            usage: ansible-vault [-h] [--version] [-v] {create,decrypt,edit,view,encrypt,encrypt_string,rekey} ...

encryption/decryption utility for Ansible data files

[...]
  </screen>
            </listitem>
          </varlistentry>
                 </variablelist>
       </section>
      <section xml:id="ansible-playbook">
       <title>Creating a playbook </title>
        <para>
         An Ansible playbook is a <literal>YAML</literal> file that defines a series of tasks to be executed on one or more hosts.
         This topic covers creating a simple playbook.
          </para>
       <procedure>
      <step><para>Set up SSH key-based authentication from the control node to each managed node.</para></step>
      <step><para>Generate a key pair on the control node.</para>
      <para>It is recommended to use a dedicated SSH key and clearly defined in the variable <literal>ansible_ssh_private_key_file</literal>.</para>
       </step>
      <step><para>Copy the public key to the managed node.</para>
      <screen>&prompt.user; ssh-copy-id -i <replaceable>PATH_TO_PUBLIC_KEY</replaceable> <replaceable>TARGET_USER</replaceable>@<replaceable>IP_ADDRESS/HOSTNAME</replaceable></screen>
      <para>This one-time setup allows Ansible to connect securely without prompting for credentials during automation.</para>
      </step>
         <step><para>Add the private key to the control node.</para>
          <screen>&prompt.user; ssh-add <replaceable>PATH_TO_PRIVATE_KEY</replaceable>
                  </screen>
           </step>
      <step><para>Define an inventory file, for example:</para>
    <screen>
      [all]
      192.168.122.154 ansible_user=user1
    </screen>
    <para>Although Ansible uses <filename>etc/ansible/hosts</filename>/ by default, it is a
      best practice to maintain a separate inventory file and specify it using the<literal>-i</literal> flag.</para>
      </step>
      <step><para>Verify your inventory file, for example:</para>
      <screen>&prompt.user;<command>ansible-inventory -i test.ini --list</command>
        </screen>
      </step>
      <step><para>Test the connection between the control node and managed nodes with the Ansible ad-hoc command:</para>
      <screen>&prompt.user;<command>ansible all -i test.ini -m ping</command></screen>
      <para>If the configuration is correct, the following message is displayed:</para>
      <screen>
        [WARNING]: Platform linux on host 192.168.122.73 is using the discovered Python interpreter at /usr/bin/python3.13, but future installation of another Python interpreter could change
        the meaning of that path. See https://docs.ansible.com/ansible-core/2.18/reference_appendices/interpreter_discovery.html for more information.
        192.168.122.73 | SUCCESS => {
            "ansible_facts": {
                "discovered_interpreter_python": "/usr/bin/python3.13"
            },</screen>
      <para>This confirms Ansible can reach the managed nodes securely via SSH. </para>
      </step>
      <step><para>Playbooks are <literal>YAML</literal> files that define the tasks Ansible should perform.
      For example, create a file named <literal>install.yml</literal> to define a task to install common packages on all managed &suse; systems:</para>
    <screen>
    - name: Ensure essential packages are present
      hosts: all
      become: true
      tasks:
        - name: Install vim and curl
          ansible.builtin.package:
            name:
              - suseconnect
              - curl
            state: present
    </screen>
    </step>
    <step><para>Run the playbook:</para>
    <screen>&prompt.user; ansible-playbook -i hosts.ini install.yml</screen>
    <para>Ansible connects to each host in your inventory and executes the defined tasks using the &systemd; package manager.</para>
    </step>
    </procedure>
        </section>
    </topic>
