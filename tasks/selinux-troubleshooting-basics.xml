<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
[
  <!ENTITY % entities SYSTEM "../common/generic-entities.ent">
    %entities;
]>
<!-- refers to legacy doc: <add github link to legacy doc piece, if applicable> -->
<!-- point back to this document with a similar comment added to your legacy doc piece -->
<!-- refer to README.md for file and id naming conventions -->
<!-- metadata is dealt with on the assembly level -->
<topic xml:id="selinux-troubleshooting"
 role="concept" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.2"
 xmlns:its="http://www.w3.org/2005/11/its"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:trans="http://docbook.org/ns/transclusion">
  <info>
    <title>Troubleshooting</title>
    <!-- can be changed via merge in the assembly -->
    <!--add author's email address-->
    <meta name="maintainer" content="jsindelarova@suse.com" its:translate="no"/>
  </info>
    <para>
    An &selnx; issue occurs when the security policy blocks a legitimate action that an application needs to perform its function. This guide provides a systematic workflow for resolving these issues. The process involves confirming that &selnx; is the cause, gathering evidence from logs, diagnosing the underlying problem, and implementing the correct solution.
  </para>

  <section xml:id="workflow-step1-triage">
    <title>Step 1: Triage - Confirming the Issue is &selnx; Related</title>
    <para>
      The initial diagnostic step is to determine if &selnx; is the cause of the unexpected behavior. This can be done by temporarily placing the system into <emphasis role="bold">permissive mode</emphasis>, where denials are logged but not enforced.
    </para>
    <procedure>
      <step>
        <para>Switch to permissive mode:</para>
        <screen>&prompt.root;<command>setenforce 0</command></screen>
      </step>
      <step>
        <para>Retry the action that was previously failing.</para>
      </step>
      <step>
        <para>Analyze the result:</para>
        <itemizedlist>
          <listitem>
            <para>If the application <emphasis role="bold">succeeds</emphasis>, the problem is confirmed to be related to the &selnx; policy. Proceed to the next step.</para>
          </listitem>
          <listitem>
            <para>If the application <emphasis role="bold">still fails</emphasis>, the root cause is likely unrelated to &selnx; and may involve other factors such as standard file permissions, firewall rules, or application configuration.</para>
          </listitem>
        </itemizedlist>
      </step>
    </procedure>
    <important>
      <para>Upon completion of the test, it is important to return the system back to enforcing mode:</para>
      <screen>&prompt.root;<command>setenforce 1</command></screen>
    </important>
  </section>

  <section xml:id="workflow-step2-evidence">
    <title>Step 2: Evidence Gathering - Finding the Denial</title>
    <para>
        Once &selnx; is confirmed as the cause, the next step is to find the specific denial message in the audit logs. The primary log file is <filename>/var/log/audit/audit.log</filename>. Use the <command>ausearch</command> utility to query these logs for recent Access Vector Cache (AVC) denials.
    </para>
<screen>&prompt.root;<command>ausearch -m avc -ts recent</command>
 type=AVC msg=audit(1753703741.779:1779): avc:  denied  { getattr } for  pid=22212 comm="httpd-prefork" path="/srv/wwwcustom/vhosts/example.com/index.html" dev="vda3" ino=278 scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:object_r:var_t:s0 tclass=file permissive=0
</screen>
    <para>
        This log entry contains the essential details: the source process context (<literal>scontext</literal>), the target object's context (<literal>tcontext</literal>), and the permission denied.
        More information on interpreting the log file can be found in <xref linkend="selinux-logs"/>.
    </para>
  </section>

  <section xml:id="workflow-step3-diagnosis">
    <title>Step 3: Diagnosis - Understanding the Cause of the Denial</title>
    <para>After reviewing the log, the denial is likely caused by one of the following common issues:</para>
    <variablelist>
      <varlistentry>
        <term>Incorrect File Label</term>
        <listitem>
         <para>This denial typically occurs in one of two scenarios: a file has an incorrect label for its current location, or the file is in a non-standard location and needs to be assigned a correct label in the policy.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Service Using a Non-Standard Port</term>
        <listitem>
          <para>A denial will occur if a service attempts to bind to a network port that is not assigned the correct port type in the &selnx; policy.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Missing Policy Rule</term>
        <listitem>
          <para>The system's &selnx; policy may lack a specific rule required for an application's operation. Especially this can happen when the application is not shipped by default with the distribution. In this case, the resulting AVC denial is valid and indicates the policy needs to be extended.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section xml:id="workflow-step4-solution">
    <title>Step 4: Resolution - Applying the Correct Fix</title>
    <para>Based on the diagnosis, apply the appropriate solution.</para>
    <variablelist>
        <varlistentry>
            <term>For Incorrect File Labels</term>
            <listitem>
              <para>The solution depends on the cause of the mislabeling:</para>
              <itemizedlist>
                <listitem>
                 <para>
                   <emphasis role="bold">Case 1: Incorrectly labelled file in filesystem.</emphasis> If files in a standard location have the wrong labels (for example, after using <command>mv</command> or <command>cp</command> without the <command>-Z</command> flag), use <command>restorecon</command> to reset them to the policy default.
                   For example, to restore the context of <filename>/srv/www/vhosts/example.com</filename>, use:
                </para>
                  <screen>&prompt.root;<command>restorecon -Rv /srv/www/vhosts/example.com</command></screen>
                </listitem>
                <listitem>
                 <para><emphasis role="bold">Case 2: Tell SELinux about a custom path.</emphasis> If you intentionally chose a non-standard location for your files (e.g., serving web content from <filename>/srv/wwwcustom</filename>), you must add a new rule to the &selnx; policy with <command>semanage fcontext</command>. Afterwards, use <command>restorecon</command> to apply the new rule.</para>
<screen>
&prompt.root;<command>semanage fcontext -a -t httpd_sys_content_t "/srv/wwwcustom(/.*)?"</command>
&prompt.root;<command>restorecon -Rv /srv/wwwcustom</command>
</screen>
                  <para>For more information on adding custom file paths, see <xref linkend="modify-context-type"/>.</para>
                </listitem>
              </itemizedlist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>For Non-Standard Ports</term>
            <listitem>
              <para>
                Use <command>semanage port</command> to add the custom port to the policy with the correct type.
                For example, to use the custom port 2222 for the SSH daemon, use:
              </para>
              <screen>&prompt.root;<command>semanage port -a -t ssh_port_t -p tcp 2222</command></screen>
              <para>For more information on adding custom file paths, see <xref linkend="selinux-modify-port"/>.</para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>For Missing Policy Rules</term>
            <listitem>
              <para>If diagnosis indicates a rule is genuinely missing from the policy, you can generate a custom module. This workflow includes a critical review step.</para>
              <procedure>
                  <step>
                    <para>Use <command>ausearch</command> to fetch all the AVCs in the timeframe. Then, optionally isolate the specific denials related to your issue with <command>grep</command>. Pipe the results to <command>audit2allow</command>. For example, to generate a module only for denials that have occurred recently, use:</para>
                    <screen>&prompt.root;<command>ausearch -m avc -ts recent | audit2allow -M my-fix</command></screen>
                    <para>This command creates two files: <filename>my-fix.te</filename> (human-readable source) and <filename>my-fix.pp</filename> (installable module).</para>
                  </step>
                  <step>
                    <para>Critically review the contents of the human-readable <filename>.te</filename> file to ensure the proposed rules are appropriate and expected.</para>
                    <screen>&prompt.user;<command>cat my-fix.te</command></screen>
                    <warning>
                        <title>Security Analysis of Generated Rules</title>
                        <para>The <command>audit2allow</command> tool translates denials into allow rules mechanically. It does not understand context or intent. Only proceed with installing a module if you fully understand the rule and are certain it does not violate your security principles.</para>
                    </warning>
                  </step>
                  <step>
                    <para><emphasis role="bold">3. (Optional) Modify and Rebuild the Module:</emphasis> If the generated rules need to be adjusted, edit the <filename>.te</filename> file. After saving your changes, you can manually recompile the module.</para>
                    <orderedlist>
                        <listitem><para>Use a text editor to modify <filename>my-fix.te</filename>.</para></listitem>
                        <listitem><para>Recreate <filename>my-fix.pp</filename>:</para>
                        <screen>&prompt.root;<command>make -f /usr/share/selinux/devel/Makefile my-fix.pp</command></screen>
                        </listitem>
                     </orderedlist>
                  </step>
                  <step>
                    <para>If, after careful review, the generated rules are deemed safe and necessary for a legitimate application function, install the compiled module package.</para>
                    <screen>&prompt.root;<command>semodule -i my-fix.pp</command></screen>
                  </step>
                </procedure>
            </listitem>
        </varlistentry>
    </variablelist>
  </section>

  <section xml:id="workflow-advanced">
    <title>Advanced Scenarios and Recovery</title>
    <section xml:id="ts-dontaudit">
        <title>Handling missing log entries (dontaudit rules)</title>
        <para>If an application fails but no denial is logged, a <literal>dontaudit</literal> rule may be silently suppressing it. You can temporarily disable these rules to make all denials visible.</para>
        <procedure>
          <step><para>Disable all <literal>dontaudit</literal> rules:</para>
            <screen>&prompt.root;<command>semodule -DB</command></screen>
          </step>
          <step><para>Retry the failing action to generate the denial log.</para></step>
          <step><para>Re-enable the rules to restore normal logging behavior:</para>
            <screen>&prompt.root;<command>semanage -B</command></screen>
          </step>
        </procedure>
    </section>
    <section xml:id="ts-boot-recovery">
        <title>Recovering from an &selnx;-related boot failure</title>
        <para>If an &selnx; policy or labeling issue prevents the system from booting, the primary goal is to regain access to a shell to diagnose and fix the problem. This can be achieved by booting the system in permissive mode.</para>
        <orderedlist>
          <listitem><para>Restart the machine and interrupt the boot sequence to access the GRUB menu.</para></listitem>
          <listitem><para>Select the desired kernel and press <keycap>e</keycap> to edit its boot parameters.</para></listitem>
          <listitem><para>Locate the line beginning with the keyword <literal>linux</literal>.</para></listitem>
          <listitem><para>Append the parameter <literal>enforcing=0</literal> to the end of this line. This instructs the kernel to boot in permissive mode for this session only.</para></listitem>
          <listitem><para>Press <keycombo><keycap>Ctrl</keycap><keycap>X</keycap></keycombo> or <keycap>F10</keycap> to proceed with booting.</para></listitem>
          <listitem><para>Once the system has booted successfully, log in and use the standard troubleshooting tools described in this guide to find the denial and apply the correct fix.</para></listitem>
        </orderedlist>
        <note>
            <title>Fixing widespread labeling issues at boot</title>
            <para>In the specific case where the boot failure is caused by incorrect file labels across the entire system, the most effective solution is to schedule a full relabel. After booting into permissive mode using the steps above, execute the following commands before rebooting:</para>
            <screen>&prompt.root;<command>touch /etc/selinux/.autorelabel</command>
&prompt.root;<command>reboot</command></screen>
            <para>The system will now reboot and begin a comprehensive relabeling of the filesystem.</para>
        </note>
    </section>
  </section>
</topic>
